<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<script src="assets/maplibre-gl/maplibre-gl.js"></script>
	<script src="assets/versatiles-style/versatiles-style.js"></script>
	<link rel="stylesheet" href="assets/maplibre-gl/maplibre-gl.css" />
	<style>
		html,
		body {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
		}

		#map {
			width: 100%;
			height: 100vh;
		}
	</style>
</head>

<body>
	<div id="map"></div>
	<script>
		const resolve = (url) => new URL(url, window.location).href;

		const style = VersaTilesStyle.colorful({
			baseUrl: 'https://tiles.versatiles.org',
			language: 'en',
		});
		style.sprite.push({ id: 's0', url: resolve('./data/sprites') });
		console.log(style);

		// Create a map instance
		const map = new maplibregl.Map({
			container: 'map',
			style,
			pitch: 0,
			bearing: 0,
			bounds: [
				[-126.601, 25.12],
				[-65.952, 49.665],
			],
			maxPitch: 0,
			dragRotate: false,
			fadeDuration: 100,
			//hash: true,
			attributionControl: {
				compact: true,
				customAttribution: [
					'<a href="https://datajournal.org" target="_blank">datajournal.org</a>',
					'<a href="https://versatiles.org" target="_blank">VersaTiles</a>',
				]
			},
		});

		// Add navigation controls
		map.addControl(new maplibregl.NavigationControl(), 'top-right');

		init();
		async function init() {
			const iconSize = 32;
			const r = iconSize / 1;
			const offsetLookup = [
				[],
				[[0, 0]],
				circle(2, r * 1.2, 0),
				circle(3, r * 1.4, -0.25),
				circle(4, r * 1.6, -0.125),
				circle(5, r * 2.0, -0.25),
				[[0, 0], ...circle(6, r * 2.3, -7 / 12)],
				[[0, 0], ...circle(6, r * 2.3, 0)],
			]

			const request = await fetch('data/data.json');
			const data = await request.json();
			const features = data.flatMap((entry, entryIndex) => {
				const { coordinates, title, region, sprites } = entry;
				if (sprites.length > 7) throw Error();

				const offsets = offsetLookup[sprites.length]
				if (offsets.length < sprites.length) throw Error();

				return sprites.map((id, spriteIndex) => ({
					type: 'Feature',
					geometry: { type: 'Point', coordinates },
					properties: {
						title, region, image: 's0:' + id,
						offset: offsets[spriteIndex],
						index: entryIndex + spriteIndex * 2000
					},
				}));
			});
			features.sort((a, b) => a.properties.index - b.properties.index);

			map.addSource('data', {
				type: 'geojson',
				data: { type: 'FeatureCollection', features },
			});

			map.addLayer({
				id: 'icons',
				type: 'symbol',
				source: 'data',
				layout: {
					'icon-image': ['get', 'image'],
					'icon-offset': ['get', 'offset'],
					'icon-size': [
						'interpolate',
						['exponential', 2],
						['zoom'],
						3, 0.1,
						7, 1.0
					],
					//'icon-allow-overlap': true,
					'icon-keep-upright': true,
					'icon-padding': [
						'interpolate',
						['exponential', 2],
						['zoom'],
						3, 0.1 * -iconSize * 0.1,
						7, 1.0 * -iconSize * 0.1
					],
					//'icon-overlap': 'always',
					//'text-field': ['get', 'title'],
					//'text-font': ['Arial Unicode MS Regular'],
					//'text-size': 12,
					//'text-anchor': 'top',
					//'text-offset': [0, 0.5],
				}
			});

			function circle(count, r, angle) {
				const points = [];
				for (let i = 0; i < count; i++) {
					const a = (i / count + angle) * Math.PI * 2;
					points.push([Math.cos(a) * r, Math.sin(a) * r]);
				}
				return points;
			}
		}
	</script>
</body>

</html>